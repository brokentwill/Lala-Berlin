/*!
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
//
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
//
// About: License
//
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
//
// About: Examples
//
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
//
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
//
// About: Support and Testing
//
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
//
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
//
// About: Release History
//
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.
//
// Topic: Note for non-jQuery users
//
// jQuery isn't actually required for this plugin, because nothing internal
// uses any jQuery methods or properties. jQuery is just used as a namespace
// under which these methods can exist.
//
// Since jQuery isn't actually required for this plugin, if jQuery doesn't exist
// when this plugin is loaded, the method described below will be created in
// the `Cowboy` namespace. Usage will be exactly the same, but instead of
// $.method() or jQuery.method(), you'll need to use Cowboy.method().


jQuery.noConflict();

(function(window,undefined){
  '$:nomunge'; // Used by YUI compressor.

  // Since jQuery really isn't required for this plugin, use `jQuery` as the
  // namespace only if it already exists, otherwise use the `Cowboy` namespace,
  // creating it if necessary.
  var $ = window.jQuery || window.Cowboy || ( window.Cowboy = {} ),

    // Internal method reference.
    jq_throttle;

  // Method: jQuery.throttle
  //
  // Throttle execution of a function. Especially useful for rate limiting
  // execution of handlers on events like resize and scroll. If you want to
  // rate-limit execution of a function to a single time, see the
  // <jQuery.debounce> method.
  //
  // In this visualization, | is a throttled-function call and X is the actual
  // callback execution:
  //
  // > Throttled with `no_trailing` specified as false or unspecified:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X    X    X    X    X    X        X    X    X    X    X    X
  // >
  // > Throttled with `no_trailing` specified as true:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X    X    X    X    X             X    X    X    X    X
  //
  // Usage:
  //
  // > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
  // >
  // > jQuery('selector').bind( 'someevent', throttled );
  // > jQuery('selector').unbind( 'someevent', throttled );
  //
  // This also works in jQuery 1.4+:
  //
  // > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
  // > jQuery('selector').unbind( 'someevent', callback );
  //
  // Arguments:
  //
  //  delay - (Number) A zero-or-greater delay in milliseconds. For event
  //    callbacks, values around 100 or 250 (or even higher) are most useful.
  //  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
  //    true, callback will only execute every `delay` milliseconds while the
  //    throttled-function is being called. If no_trailing is false or
  //    unspecified, callback will be executed one final time after the last
  //    throttled-function call. (After the throttled-function has not been
  //    called for `delay` milliseconds, the internal counter is reset)
  //  callback - (Function) A function to be executed after delay milliseconds.
  //    The `this` context and all arguments are passed through, as-is, to
  //    `callback` when the throttled-function is executed.
  //
  // Returns:
  //
  //  (Function) A new, throttled, function.

  $.throttle = jq_throttle = function( delay, no_trailing, callback, debounce_mode ) {
    // After wrapper has stopped being called, this timeout ensures that
    // `callback` is executed at the proper times in `throttle` and `end`
    // debounce modes.
    var timeout_id,

      // Keep track of the last time `callback` was executed.
      last_exec = 0;

    // `no_trailing` defaults to falsy.
    if ( typeof no_trailing !== 'boolean' ) {
      debounce_mode = callback;
      callback = no_trailing;
      no_trailing = undefined;
    }

    // The `wrapper` function encapsulates all of the throttling / debouncing
    // functionality and when executed will limit the rate at which `callback`
    // is executed.
    function wrapper() {
      var that = this,
        elapsed = +new Date() - last_exec,
        args = arguments;

      // Execute `callback` and update the `last_exec` timestamp.
      function exec() {
        last_exec = +new Date();
        callback.apply( that, args );
      };

      // If `debounce_mode` is true (at_begin) this is used to clear the flag
      // to allow future `callback` executions.
      function clear() {
        timeout_id = undefined;
      };

      if ( debounce_mode && !timeout_id ) {
        // Since `wrapper` is being called for the first time and
        // `debounce_mode` is true (at_begin), execute `callback`.
        exec();
      }

      // Clear any existing timeout.
      timeout_id && clearTimeout( timeout_id );

      if ( debounce_mode === undefined && elapsed > delay ) {
        // In throttle mode, if `delay` time has been exceeded, execute
        // `callback`.
        exec();

      } else if ( no_trailing !== true ) {
        // In trailing throttle mode, since `delay` time has not been
        // exceeded, schedule `callback` to execute `delay` ms after most
        // recent execution.
        //
        // If `debounce_mode` is true (at_begin), schedule `clear` to execute
        // after `delay` ms.
        //
        // If `debounce_mode` is false (at end), schedule `callback` to
        // execute after `delay` ms.
        timeout_id = setTimeout( debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay );
      }
    };

    // Set the guid of `wrapper` function to the same of original callback, so
    // it can be removed in jQuery 1.4+ .unbind or .die by using the original
    // callback as a reference.
    if ( $.guid ) {
      wrapper.guid = callback.guid = callback.guid || $.guid++;
    }

    // Return the wrapper function.
    return wrapper;
  };

  // Method: jQuery.debounce
  //
  // Debounce execution of a function. Debouncing, unlike throttling,
  // guarantees that a function is only executed a single time, either at the
  // very beginning of a series of calls, or at the very end. If you want to
  // simply rate-limit execution of a function, see the <jQuery.throttle>
  // method.
  //
  // In this visualization, | is a debounced-function call and X is the actual
  // callback execution:
  //
  // > Debounced with `at_begin` specified as false or unspecified:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // >                          X                                 X
  // >
  // > Debounced with `at_begin` specified as true:
  // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
  // > X                                 X
  //
  // Usage:
  //
  // > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
  // >
  // > jQuery('selector').bind( 'someevent', debounced );
  // > jQuery('selector').unbind( 'someevent', debounced );
  //
  // This also works in jQuery 1.4+:
  //
  // > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
  // > jQuery('selector').unbind( 'someevent', callback );
  //
  // Arguments:
  //
  //  delay - (Number) A zero-or-greater delay in milliseconds. For event
  //    callbacks, values around 100 or 250 (or even higher) are most useful.
  //  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
  //    unspecified, callback will only be executed `delay` milliseconds after
  //    the last debounced-function call. If at_begin is true, callback will be
  //    executed only at the first debounced-function call. (After the
  //    throttled-function has not been called for `delay` milliseconds, the
  //    internal counter is reset)
  //  callback - (Function) A function to be executed after delay milliseconds.
  //    The `this` context and all arguments are passed through, as-is, to
  //    `callback` when the debounced-function is executed.
  //
  // Returns:
  //
  //  (Function) A new, debounced, function.

  $.debounce = function( delay, at_begin, callback ) {
    return callback === undefined
      ? jq_throttle( delay, at_begin, false )
      : jq_throttle( delay, callback, at_begin !== false );
  };

})(this);


/* **********************************************
     Begin jq.smoothScroll.js
********************************************** */
jQuery.noConflict();

;(function($, window, document, undefined) {
  $(function() {
    $('a[href*=#]:not([href=#])').click(function() {
      if (location.pathname.replace(/^\//,'') == this.pathname.replace(/^\//,'') && location.hostname == this.hostname) {
        var target = $(this.hash);
        target = target.length ? target : $('[name=' + this.hash.slice(1) +']');
        if (target.length) {
          $('html,body').animate({
            scrollTop: target.offset().top
          }, 500);
          return false;
        }
      }
    });
  });
})(jQuery, window, document, undefined);

/* **********************************************
     Begin jq.windows.js
********************************************** */

/*!
 * windows: a handy, loosely-coupled jQuery plugin for full-screen scrolling windows.
 * Version: 0.0.1
 * Original author: @nick-jonas
 * Website: http://www.workofjonas.com
 * Licensed under the MIT license
 */

jQuery.noConflict();

;(function ( $, window, document, undefined ) {


var that = this,
        pluginName = 'windows',
        defaults = {
            snapping: true,
            snapSpeed: 500,
            snapInterval: 1100,
            onScroll: function(){},
            onSnapComplete: function(){},
            onWindowEnter: function(){}
        },
        options = {},
        $w = $(window),
        s = 0, // scroll amount
        t = null, // timeout
        $windows = [];

    /**
     * Constructor
     * @param {jQuery Object} element       main jQuery object
     * @param {Object} customOptions        options to override defaults
     */
    function windows( element, customOptions ) {

        this.element = element;
        options = options = $.extend( {}, defaults, customOptions) ;
        this._defaults = defaults;
        this._name = pluginName;
        $windows.push(element);
        var isOnScreen = $(element).isOnScreen();
        $(element).data('onScreen', isOnScreen);
        if(isOnScreen) options.onWindowEnter($(element));

    }

    /**
     * Get ratio of element's visibility on screen
     * @return {Number} ratio 0-1
     */
    $.fn.ratioVisible = function(){
        var s = $w.scrollTop();
        if(!this.isOnScreen()) return 0;
        var curPos = this.offset();
        var curTop = curPos.top - s;
        var screenHeight = $w.height();
        var ratio = (curTop + screenHeight) / screenHeight;
        if(ratio > 1) ratio = 1 - (ratio - 1);
        return ratio;
    };

    /**
     * Is section currently on screen?
     * @return {Boolean}
     */
    $.fn.isOnScreen = function(){
        var s = $w.scrollTop(),
            screenHeight = $w.height(),
            curPos = this.offset(),
            curTop = curPos.top - s;
        return (curTop >= screenHeight || curTop <= -screenHeight) ? false : true;
    };

    /**
     * Get section that is mostly visible on screen
     * @return {jQuery el}
     */
    var _getCurrentWindow = $.fn.getCurrentWindow = function(){
        var maxPerc = 0,
            maxElem = $windows[0];
        $.each($windows, function(i){
            var perc = $(this).ratioVisible();
            if(Math.abs(perc) > Math.abs(maxPerc)){
                maxElem = $(this);
                maxPerc = perc;
            }
        });
        return $(maxElem);
    };


    // PRIVATE API ----------------------------------------------------------

    /**
     * Window scroll event handler
     * @return null
     */
    var _onScroll = function(){
        s = $w.scrollTop();

        _snapWindow();

        options.onScroll(s);

        // notify on new window entering
        $.each($windows, function(i){
            var $this = $(this),
                isOnScreen = $this.isOnScreen();
            if(isOnScreen){
                if(!$this.data('onScreen')) options.onWindowEnter($this);
            }
            $this.data('onScreen', isOnScreen);
        });
    };

    var _onResize = function(){
        _snapWindow();
    };

    var _snapWindow = function(){
        // clear timeout if exists
        if(t){clearTimeout(t);}
        // check for when user has stopped scrolling, & do stuff
        if(options.snapping){
            t = setTimeout(function(){
                var $visibleWindow = _getCurrentWindow(), // visible window
                    isSmaller = $visibleWindow.height() < ($w.height() + 10),
                    isLower = $visibleWindow.offset().top > $w.scrollTop();

                console.log('isSmaller ?', $visibleWindow, isSmaller);

                if (isSmaller || (!isSmaller && isLower)) {
                    console.log('snapping');
                    var scrollTo = $visibleWindow.offset().top, // top of visible window
                        completeCalled = false;
                    // animate to top of visible window
                    $('html:not(:animated),body:not(:animated)').animate({scrollTop: scrollTo }, options.snapSpeed, function(){
                        if(!completeCalled){
                            if(t){clearTimeout(t);}
                            t = null;
                            completeCalled = true;
                            options.onSnapComplete($visibleWindow);
                        }
                    });
                }
            }, options.snapInterval);
        }
    };


    /**
     * A really lightweight plugin wrapper around the constructor,
        preventing against multiple instantiations
     * @param  {Object} options
     * @return {jQuery Object}
     */
    $.fn[pluginName] = function ( options ) {

        $w.scroll(_onScroll);
        $w.resize(_onResize);

        return this.each(function(i) {
            if (!$.data(this, 'plugin_' + pluginName)) {
                $.data(this, 'plugin_' + pluginName,
                new windows( this, options ));
            }
        });
    };

})( jQuery, window, document );

/* **********************************************
     Begin jq.widget.js
********************************************** */

;
// Make sure Object.create is available in the browser (for our prototypal inheritance)
// Courtesy of Papa Crockford
// Note this is not entirely equal to native Object.create, but compatible with our use-case
if (typeof Object.create !== 'function') {
  Object.create = function (o) {
    function F() {} // optionally move this outside the declaration and into a closure if you need more speed.
    F.prototype = o;
    return new F();
  };
}


jQuery.noConflict();

(function($) {
  // a factory method for constructing a jQuery plugin. Courtesy of Alex Sexton:
  // http://alexsexton.com/blog/2010/02/using-inheritance-patterns-to-organize-large-jquery-applications/
  $.widget = function(widgetName, widgetObj) {
    // register the plugin to the jquery fn namespace
    $.fn[widgetName] = function(options) {
      var params = Array.prototype.slice.call(arguments, 1);
      return this.each(function(i) {
        var $this = $(this),
          instance = $this.data('widget_' + widgetName);

        // instantiate Object if it has not been done yet
        if(!instance) {
          instance = $this.data('widget_' + widgetName, new widgetObj($this, options));
        }

        // allow for calling Class methods with a string option
        if(typeof options === 'string') {
          // allow for multiple arguments to be passed to a widget's method
          instance[options].apply(instance, params);
        }
      });
    };
  };

})(jQuery);

/* **********************************************
     Begin jq.collapsible.js
********************************************** */
jQuery.noConflict();

;(function($, document, undefined) {

  var defaults = {
    activeClass: 'active'
  },

  Collapsible = function(el, options) {
    this.$el = el instanceof jQuery ? el: $(el);
    this.el = this.$el[0];
    this.opts = $.extend({}, defaults, options || {});

    this.init();
  };

  Collapsible.prototype = {

    init: function() {
      // sync with current state set in the dom
      this._active = this.$el.hasClass(this.opts.activeClass);
    },

    show: function() {
      // stop if the element is already active
      if (this._active === true) { return; }

      this._active = true;
      this.$el.addClass(this.opts.activeClass);

      this.$el.trigger('show.collapsible');
    },

    hide: function() {
      // stop if the element isn't active
      if (this._active === false) { return; }

      this._active = false;
      this.$el.removeClass(this.opts.activeClass);

      this.$el.trigger('hide.collapsible');
    },

    toggle: function() {
      this[this._active ? 'hide': 'show']();
    },

    // alias for 'this.show()'
    open: function() { this.show(); },
    // alias for 'this.hide()'
    close: function() { this.hide(); }
  };

  $.widget('collapsible', Collapsible);

})(jQuery, document, undefined);

/* **********************************************
     Begin jq.toggleButton.js
********************************************** */

jQuery.noConflict();

;(function($, document, undefined) {

  this.$document = this.$document || $(document);

  var defaults = {},

  ToggleButton = function(el, options) {
    this.$el = el instanceof jQuery ? el: $(el);
    this.el = this.$el[0];
    this.opts = $.extend({}, defaults, options || {});

    this.init();
  };

  ToggleButton.prototype = {
    init: function(el, options) {
      this.$target = $( this.$el.attr('data-target') || this.$el.attr('href') );
      this.targetWidget = this.$el.attr('data-toggle');

      this._listen();
    },

    // TODO:: CLEANUP THE TOGGLE METHOD AND THE WAY IT IS CALLED
    _listen: function() {
      this.$el.on('click.toggleButton', function(ev) {
        $(this).toggleButton('toggle');
      });
    },

    toggle: function() {
      this.$target[this.targetWidget]('toggle');
    }
  };

  $.widget('toggleButton', ToggleButton);

})(jQuery, document, undefined);

/* **********************************************
     Begin jq.closeButton.js
********************************************** */
jQuery.noConflict();

;(function($, document, undefined) {

  window.$document = window.$document || $(document);

  var defaults = {},

  CloseButton = function(el, options) {
    this.$el = el instanceof jQuery ? el: $(el);
    this.el = this.$el[0];
    this.opts = $.extend({}, defaults, options || {});

    this.init();
  };

  CloseButton.prototype = {
    init: function(el, options) {
      this.$target = $( this.$el.attr('data-target') || this.$el.attr('href') );
      this.targetWidget = this.$el.attr('data-close');

      this._listen();
    },

    // TODO:: CLEANUP THE CLOSE METHOD AND THE WAY IT IS CALLED
    _listen: function() {
      this.$el.on('click.closeButton', function(ev) {
        ev.preventDefault();
        $(this).closeButton('close');
      });
    },

    close: function() {
      this.$target[this.targetWidget]('close');
    }
  };

  $.widget('closeButton', CloseButton);

})(jQuery, document, undefined);

/* **********************************************
     Begin view-cover.js
********************************************** */
jQuery.noConflict();

window.$window = window.$window || $(window);

jQuery(document).ready(function() {
  updateViewCovers();
});

var $viewCovers = $('.view-cover');


function updateViewCovers() {
  jQuery('.view-cover').css('min-height', jQuery(window).height());
}

jQuery(window).on('resize', function() {
  updateViewCovers();
});

updateViewCovers();

/* **********************************************
     Begin img-cover.js
********************************************** */
jQuery.noConflict();

(function($) {

  $('.img-cover').each(function(i) {
    var $holder = $(this),
      $img = $holder.find('img').first();
    $holder.css('background-image', 'url(' + $img.attr('src') + ')');
  });

})(jQuery);

/* **********************************************
     Begin embed-cover.js
********************************************** */


(function($) {

  window.$window = window.$window || $(window);
  var $coverVids = $('.vid-cover');

  $coverVids.each(function(i) {
    var $holder = $(this),
      $vid = $holder.find('video').first();

    init($vid);
    update($holder, $vid);
  });

  jQuery(window).on('resize', $.debounce(150, function(ev) {
    console.log('yooo');
    $coverVids.each(function(i) {
      var $holder = $(this);
      update( $holder, $holder.find('video').first() );
    });
  }));

  function init($vid) {
    $vid.css({
      'top': '50%',
      'left': '50%'
    });
  }

  function update($holder, $vid) {
    var holderW = $holder.width(),
      holderH = $holder.height(),
      holderR = (holderH/holderW),
      vidW = $vid.width(),
      vidH = $vid.height(),
      vidR = (vidH/vidW);

    if (vidR >= holderR) {
      $vid.css({
        'margin-top': -0.5 * vidH,
        'margin-left': -0.5 * vidW,
        'width': holderW,
        'height': 'auto'
      });
    }

    else if (holderR >= vidR) {
      $vid.css({
        'margin-top': -0.5 * vidH,
        'margin-left': -0.5 * vidW,
        'width': 'auto',
        'height': holderH
      });
    }
  }

})(jQuery);

/* **********************************************
     Begin sticker.js
********************************************** */
jQuery.noConflict();

(function($, window, document, undefined) {

  var defaults = {
    onStick: function() {},
    onUnstick: function() {}
  },

  Sticker = function(el, styles, options) {
    this.$el = el instanceof jQuery ? el : $(el);
    this.el = this.$el[0];
    this.init(styles, options);
  };

  Sticker.prototype = {
    init: function(styles, options) {
      this.options = $.extend({}, defaults, options || {});
      this.setStyles(styles);
      this.listen();
    },

    listen: function() {
      var self = this;
      $w.on('scroll', function(ev) {
        self.stick();
      });

      $w.on('resize', function(ev) {
        self.originalTop = $w.height();
      });
    },

    setStyles: function(styles) {
      var self = this,
        st = styles || {};

      this.originalTop = this.$el.offset().top;
      this.originalStyles = { 'position' : self.$el.css('position') };
      this.stickyStyles = $.extend({'position': 'fixed'}, st);

      $.each(st, function(styleProp, styleVal) {
        self.originalStyles[styleProp] = self.$el.css(styleProp);
      });
    },

    stick : function() {
      var scrollTop = $w.scrollTop();

      if (this.originalTop <= scrollTop) {
        this.$el.css(this.stickyStyles);
        if (!this.sticked) { this.options.onStick(this.$el); }
        this.sticked = true;
      }

      else {
        this.$el.css(this.originalStyles);
        if (this.sticked) { this.options.onUnstick(this.$el); }
        this.sticked = false;
      }
    }
  };

  $.fn.sticker = function(styles, options) {
    return this.each(function(i) {
      var $this = $(this),
        instance = $this.data('plugin_sticker');

      if (!instance) {
        $this.data('plugin_sticker', new Sticker(this, styles, options));
      }

    });
  };
})(jQuery, window, document, undefined);

/* **********************************************
     Begin main.js
********************************************** */


// @codekit-prepend "vendor/jq.throttle-debounce.js"
// @codekit-prepend "vendor/jq.smoothScroll.js"
// @codekit-prepend "vendor/jq.windows.js"
// @codekit-prepend "modules/jq.widget.js"
// @codekit-prepend "modules/jq.collapsible.js"
// @codekit-prepend "modules/jq.toggleButton.js"
// @codekit-prepend "modules/jq.closeButton.js"
// @codekit-prepend "modules/view-cover.js"
// @codekit-prepend "modules/img-cover.js"
// @codekit-prepend "modules/embed-cover.js"
// @codekit-prepend "modules/sticker.js"

jQuery.noConflict();

var $w = $(window),
  $menus = $('.menu'),
  $menu1 = $('#menu'),
  $menu2 = $('#menu2'),
  $menu3 = $('#menu3'),
  $menu4 = $('#menu4'),
  $menuButton = jQuery('.menu-button').toggleButton(),
  $menuClose = $('.menu-close'),
  $hoverMenus = $('#menu1, #menu2'),
  $buttonMenus = $('#menu3, #menu4'),
  $otherMenus = $('#menu3, #menu4, #menu5, #menu6'),
  $mostMenus = $('#menu1, #menu2, #menu3, #menu4, #menu6'),
  $scrollCollapsibles = $('.scroll-collapse');

jQuery('#menu1, #menu2, #menu3, #menu4, #menu6').collapsible();
jQuery('.scroll-collapse').collapsible();

// = HOVER-MENUS
// -------------
jQuery('#menu1, #menu2').sticker({ 'top' : 0 }, {
  onStick: function($el) { setTimeout(function() { $el.collapsible('hide'); }, 25); },
  onUnstick: function($el) { setTimeout(function() { $el.collapsible('show'); }, 25); }
});

jQuery('#menu1, #menu2').on('mouseenter', '#menu-main, #menu-user', function(ev) {
  jQuery('#menu1, #menu2').collapsible('show');
});

jQuery('#menu1, #menu2').on('mousleave', '#menu-main, #menu-user', function(ev) {
  jQuery('#menu1, #menu2').collapsible('hide');
});

// = SCROLLING-MENUS
// -----------------

var prevScroll = jQuery(window).scrollTop();

jQuery(window).on('scroll', function(ev) {
  var currScroll = jQuery(window).scrollTop(),
    goingUp = currScroll < prevScroll;

  // scrolling up
  if (goingUp) {
    if (jQuery('.scroll-collapse').length) {
      jQuery('.scroll-collapse').each(function(i) {
        var $this = $(this),
          sticker = $this.data('plugin_sticker');

        if (sticker && !sticker.sticked) {
          return;
        }
        console.log('blublablbkla', $this);
        $this.collapsible('show');
      });
    }
  }

  // scrolling down
  else {
    if (jQuery('.scroll-collapse').length) {
      jQuery('.scroll-collapse').each(function(i) {
        var $this = $(this),
          sticker = $this.data('plugin_sticker');

        if (sticker && !sticker.sticked) {
          return;
        }
        console.log('blublablbkla', $this);
        $this.collapsible('hide');
      });
    }
  }

  prevScroll = currScroll;
});

$menuButton.collapsible();
jQuery('.menu').on('show.collapsible', function() { if ($menuButton.length) { $menuButton.collapsible('hide'); } });
jQuery('.menu').on('hide.collapsible', function() { if ($menuButton.length) { $menuButton.collapsible('show'); } });

jQuery('.menu-close').on('click', function(ev) {
  console.log('clicked menu close');
});

jQuery('.menu-close').closeButton();

// = BUTTON-MENUS
// ---------------

jQuery('#menu3, #menu4, #menu5, #menu6').sticker({ 'top' : 0 });

jQuery('#menu1, #menu2, #menu3, #menu4, #menu6').on('click', function(ev) {
  if ( $(ev.target).hasClass('menu') ) {
    jQuery('.menu').collapsible('hide');
  }
});

// $('.view-fill, .view-fit').windows({
//  snapping: true,
//  snapSpeed: 500,
//  snapInterval: 800,
//  onScroll: function(scrollPos){
//    // scrollPos:Number
//  },
//  onSnapComplete: function($el){
//    // after window ($el) snaps into place
//  },
//  onWindowEnter: function($el){
//    // when new window ($el) enters viewport
//  }
// });

